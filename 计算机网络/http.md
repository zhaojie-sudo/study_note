# http/https

1. WWW 构建技术
- html
- http
- url
3. http 
- 无状态 第一次和服务器连接平且登录成功后，第二次请求服务器仍然不知道当前请求的是哪个用户
- 明文传输 信息透明 容易被窃取
- 不安全
    - 通信使用明文 不加密 内容可能被窃听   

        https 在tcp 和 http 之间加入了 ssl/tls 安全协议， 使得报文能够加密传输
    - 不验证通信方身份 有可能遭遇伪装

        https 协议需要向 CA 证书权威机构 申请数字证书，以保证服务器身份可信
    - 无法证明报文的完整性 有可能被纂改
4. https = http + SSL/TSL
- http hyper text transfer protocol
- https hyper text transfer protocol secure
- ssl secure socket layer
- tsl transfer layer security
5. http 80 https 443
6. https 采用对称加密和非对称加密的 混合加密方式

    通信建立前：采用非对称加密交换会话密钥，后续不再使用非对称密钥

    通信建立中：全部使用对称加密的 会话密钥 方式，加密明文数据

    参考 [彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231)
7. **中间人攻击** 狸猫换太子
2. http 报文格式
- http 请求报文 主要由 请求行、请求头、请求体构成
    - 请求行 请求方法 url 协议版本号 POST /chapter17/user.html HTTP/1.1
        - 请求方法 GET POST PUT DELETE PATCH HEAD OPTIONS TRACE
        - URL <协议>：//<主机>：<端口>/<路径>？<参数>
        - 协议版本号 http版本号
    - 请求头 key: value
    - 请求体 数据
- http 响应报文 主要由 响应行 响应头 响应主体构成
    - 响应行 协议版本 状态码 状态码描述
8. http状态码
- 1** 提示信息，目前是协议处理的中间状态，需要后续操作
- 2** 成功，报文已经收到并且正确处理
    - 200 客户端请求成功
    - 206 
- 3** 重定向，资源位置发生变动，需要客户端重新发送请求
    - 301 永久重定向
    - 302 临时重定向
    - 304 
- 4** 客户端错误，请求报文有误，服务器无法处理
    - 400 请求语法有误
    - 401 请求需要认证
    - 403 请求资源禁止访问
    - 404 无法找到该资源
- 5** 服务器错误，服务器在处理请求时内部发生了错误
    - 500 服务器内部错误
    - 503 服务器正忙
9. http请求方法
- GET 申请获取资源
- POST 向服务器提交数据
- HEAD 要求服务器返回头部信息
- PUT 上传某个资源
- DELETE 删除某个资源
- TRACE 测试，返回原始http请求内容
- CONNECT 代理服务器
- OPTION 查询服务器对特定url支持的请求方法

10. cookie session
- cookie
    1. 第一次登录服务器，返回cookie给浏览器
    2. 浏览器将cookie保存本地
    3. 下次发送请求 自动附带cookie
    4. 服务器通过 cookie 判断用户
- session
    session 保存在服务器
11. http版本特性
- http1.1
    - 默认持久连接
    - 管线化 客户端可以同时发送多个http请求 不用等待响应
    - 断点续传
- http2.0
    - 传输格式采用了二进制格式 不是之前的基于文本
    - 多路复用
    - header压缩
    - 服务器推送

## https的加密原理
### 为什么需要加密？

http明文传输,容易被中间人劫持、篡改
### 加密方式？为什么混合加密？混合加密过程
加密方式主要有对称加密 非对称加密 混合加密

对称加密 无法向对方安全传输的传输密钥

双向非对称加密 可以保证传输的密钥不被中间人知道 但是不能防范中间人掉包 非对称加密解密非常耗时

混合加密
- 某网站拥有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。
- 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。
### 中间人攻击 "狸猫换太子"
- 某网站有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。
- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。
- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。
### 如何证明浏览器收到的公钥一定是该网站的公钥？

根本原因是浏览器无法确认收到的公钥是不是网站自己的
CA机构颁发身份证 数字证书
- 公钥；// 这里的公钥指的是网站服务器的公钥
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的数字签名及使用的算法；
- 证书有效期；
- 还有一些其他额外信息；

### 如何防止数字证书被篡改？ 数字签名

数字签名的制作过程：

- CA机构拥有非对称加密的私钥和公钥。
- CA机构对证书明文数据T进行hash。
- 对hash后的值用私钥加密，得到数字签名S。

浏览器验证过程：

- 拿到证书，得到明文T，签名S。
- 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
- 用证书里指明的hash算法对明文T进行hash得到T’。
- 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

### 证书认证过程

操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只需要服务器发送来它的证书，就可以验证证书里的签名，顺着证书链（Certficate Chain）一层层地验证，直到找到根证书。

服务器返回的是一个证书链，然后操作系统或浏览器就可以使用信任的根证书（根公钥）解析根证书得到一级证书的公钥+摘要验签，然后拿一级证书的公钥解密一级证书得到二级证书的公钥+摘要验签，再然后拿二级证书的公钥解密二级证书得到服务器的公钥和摘要验签名，验证过程就此结束！

